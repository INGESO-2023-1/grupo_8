{"ast":null,"code":"import axios from 'axios';\nconst baseURL = 'http://127.0.0.1:8000/api/';\nconst axiosInstance = axios.create({\n  baseURL: baseURL,\n  timeout: 5000,\n  headers: {\n    'Authorization': localStorage.getItem('access_token') ? \"JWT \" + localStorage.getItem('access_token') : null,\n    'Content-Type': 'application/json',\n    'accept': 'application/json'\n  }\n});\naxiosInstance.interceptors.response.use(response => response, error => {\n  const originalRequest = error.config;\n\n  // Prevent infinite loops\n  if (error.response.status === 401 && originalRequest.url === baseURL + 'token/refresh/') {\n    window.location.href = '/login/';\n    return Promise.reject(error);\n  }\n  if (error.response.data.code === \"token_not_valid\" && error.response.status === 401 && error.response.statusText === \"Unauthorized\") {\n    const refreshToken = localStorage.getItem('refresh_token');\n    if (refreshToken) {\n      const tokenParts = JSON.parse(atob(refreshToken.split('.')[1]));\n\n      // exp date in token is expressed in seconds, while now() returns milliseconds:\n      const now = Math.ceil(Date.now() / 1000);\n      console.log(tokenParts.exp);\n      if (tokenParts.exp > now) {\n        return axiosInstance.post('/token/refresh/', {\n          refresh: refreshToken\n        }).then(response => {\n          localStorage.setItem('access_token', response.data.access);\n          localStorage.setItem('refresh_token', response.data.refresh);\n          axiosInstance.defaults.headers['Authorization'] = \"JWT \" + response.data.access;\n          originalRequest.headers['Authorization'] = \"JWT \" + response.data.access;\n          return axiosInstance(originalRequest);\n        }).catch(err => {\n          console.log(err);\n        });\n      } else {\n        console.log(\"Refresh token is expired\", tokenParts.exp, now);\n        window.location.href = '/login/';\n      }\n    } else {\n      console.log(\"Refresh token not available.\");\n      window.location.href = '/login/';\n    }\n  }\n\n  // specific error handling done elsewhere\n  return Promise.reject(error);\n});\nexport default axiosInstance;","map":{"version":3,"names":["axios","baseURL","axiosInstance","create","timeout","headers","localStorage","getItem","interceptors","response","use","error","originalRequest","config","status","url","window","location","href","Promise","reject","data","code","statusText","refreshToken","tokenParts","JSON","parse","atob","split","now","Math","ceil","Date","console","log","exp","post","refresh","then","setItem","access","defaults","catch","err"],"sources":["C:/Users/felip/OneDrive/Escritorio/grupo_8/FRONT/src/axiosApi.js"],"sourcesContent":["import axios from 'axios'\r\n\r\nconst baseURL = 'http://127.0.0.1:8000/api/'\r\n\r\nconst axiosInstance = axios.create({\r\n    baseURL: baseURL,\r\n    timeout: 5000,\r\n    headers: {\r\n        'Authorization': localStorage.getItem('access_token') ? \"JWT \" + localStorage.getItem('access_token') : null,\r\n        'Content-Type': 'application/json',\r\n        'accept': 'application/json'\r\n    }\r\n});\r\n\r\n\r\naxiosInstance.interceptors.response.use(\r\n    response => response,\r\n    error => {\r\n        const originalRequest = error.config;\r\n\r\n        // Prevent infinite loops\r\n        if (error.response.status === 401 && originalRequest.url === baseURL+'token/refresh/') {\r\n            window.location.href = '/login/';\r\n            return Promise.reject(error);\r\n        }\r\n\r\n        if (error.response.data.code === \"token_not_valid\" &&\r\n            error.response.status === 401 && \r\n            error.response.statusText === \"Unauthorized\") \r\n            {\r\n                const refreshToken = localStorage.getItem('refresh_token');\r\n\r\n                if (refreshToken){\r\n                    const tokenParts = JSON.parse(atob(refreshToken.split('.')[1]));\r\n\r\n                    // exp date in token is expressed in seconds, while now() returns milliseconds:\r\n                    const now = Math.ceil(Date.now() / 1000);\r\n                    console.log(tokenParts.exp);\r\n\r\n                    if (tokenParts.exp > now) {\r\n                        return axiosInstance\r\n                        .post('/token/refresh/', {refresh: refreshToken})\r\n                        .then((response) => {\r\n            \r\n                            localStorage.setItem('access_token', response.data.access);\r\n                            localStorage.setItem('refresh_token', response.data.refresh);\r\n            \r\n                            axiosInstance.defaults.headers['Authorization'] = \"JWT \" + response.data.access;\r\n                            originalRequest.headers['Authorization'] = \"JWT \" + response.data.access;\r\n            \r\n                            return axiosInstance(originalRequest);\r\n                        })\r\n                        .catch(err => {\r\n                            console.log(err)\r\n                        });\r\n                    }else{\r\n                        console.log(\"Refresh token is expired\", tokenParts.exp, now);\r\n                        window.location.href = '/login/';\r\n                    }\r\n                }else{\r\n                    console.log(\"Refresh token not available.\")\r\n                    window.location.href = '/login/';\r\n                }\r\n        }\r\n      \r\n     \r\n      // specific error handling done elsewhere\r\n      return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default axiosInstance"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}